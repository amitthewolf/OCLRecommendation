# -*- coding: utf-8 -*-
"""Node2Vec.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ECt7CYXSar5BYFp4No6ecNW2mV1PTI7E
"""

# !pip install nodevectors
# !pip install node2vec
# !pip install karateclub

import sqlite3
import pandas as pd
import numpy as np
import networkx as nx

# from node2vec import Node2Vec

import csrgraph as cg
import nodevectors
from nodevectors import Node2Vec

import pandas.io.sql as psql
import math
from DAO import DAO
# from google.colab import drive
# drive.mount('/content/drive')

# function that adds nodes, edges according to modelID
def model2graph(graph, model_ID):
    result = df_relations.loc[df_relations['ModelID'] == model_ID]
    for index, relation in result.iterrows():
      if not math.isnan(relation[2]) and not math.isnan(relation[0]):
        graph.add_edge(relation[0], relation[2], edge1=relation[0], edge2=relation[2])
        graph.add_node(relation[0], model_ID=model_ID, object_ID=relation[0])
        graph.add_node(relation[2], model_ID=model_ID, object_ID=relation[2])



def createRelationsDF():
  df_relations = pd.read_sql("Select ObjectID1,ModelID, ObjectID2 from relations", con)
  df_relations = df_relations.dropna()


  # add objects from objects table that dont exist in relations table
  i = 256453
  for index, row in df_objects.iterrows():
    if row[0] not in df_relations.values:
      df_relations.loc[i] = [row[0],row[1],row[0]]
      i+=1

  df_relations = df_relations.dropna()
  df_relations = df_relations.drop_duplicates()

  #check which objects exist in relations and doesnt exist in object tables

  for index, row in df_relations.iterrows():
    if row[0] not in df_objects.values or row[2] not in df_objects.values:
      df_relations.drop(df_relations.index[index])
  #
  df_relations.to_csv('relations_final.csv')

con = sqlite3.connect('Pipeline Database.db')
c = con.cursor()

df_objects = pd.read_sql("Select ObjectID, ModelID from objects", con)

bla = ['ObjectID1','ModelID', 'ObjectID2']
df_relations = pd.read_csv("relations_final.csv").sort_values(by=['ObjectID1'])
df_relations = df_relations[bla]
print(df_relations.columns)

print(df_relations.head())

# init a graph
graph = nx.Graph()

# add all nodes and edges to the graph
for i in range(1, 5):
  model2graph(graph, i)

H = nx.Graph()
H.add_nodes_from(sorted(graph.nodes(data=True)))
H.add_edges_from(graph.edges(data=True))

# NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))
# fit node2vec
ggvec_model = nodevectors.GGVec()
embeddings = ggvec_model.fit_transform(graph)

# # add 32 columns to objects table (one for each of the vector dimensions)
for i in range (1, 33):
  s = 'node2vec_'+str(i)
  df_objects[s] = ''

# # new columns
cols = [col for col in df_objects.columns if col not in ['ObjectID', 'ModelID']]

#
# df = pd.read_csv("/content/drive/MyDrive/data_of_objects.csv")
# #
for row in df_objects.loc[:3].iterrows():
  df_objects.loc[df_objects['ObjectID']==row.ObjectID,cols] = ggvec_model.predict(row.ObjectID)

print(embeddings[:3])
print('*' * 50)
print(df_objects[:3])


# function that adds nodes, edges according to modelID
# def model2graph4real(model_ID):
#   graph = nx.Graph()
#   # graph.add_node('ModelID_'+str(model_ID))
#   graph.add_node(model_ID)
#   objs = df_objects.loc[df_objects['ModelID'] == model_ID]
#   for index, objects in objs.iterrows():
#     graph.add_edge(model_ID, objects[0])
#     graph.add_edge(objects[0], model_ID)
#   result = df_relations.loc[df_relations['ModelID'] == model_ID]
#   for index, relation in result.iterrows():
#     if not math.isnan(relation[2]) and not math.isnan(relation[0]):
#       graph.add_edge(relation[0], relation[2])
#       graph.add_node(relation[0])
#       graph.add_node(relation[2])
#   return graph
#
# all_graphs = list()
# for i in range(1, 319):
#   all_graphs.append(model2graph4real(i))
#
# all_graphs[0].nodes()
# dir(graph)

# from karateclub.graph_embedding import GL2Vec

# model = GL2Vec()

# model.fit(all_graphs)

# model.get_embedding()